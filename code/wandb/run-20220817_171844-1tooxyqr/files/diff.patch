diff --git a/code/convert.py b/code/convert.py
index 770c5ab..d12f69a 100644
--- a/code/convert.py
+++ b/code/convert.py
@@ -61,37 +61,62 @@ def quat2pos(quat, start_pos):
 
     Input:
         quat: Original predictions (quaternion motion)
+            (batch, .., 7)
         start_pos: Start position of simulation
+            (batch, .., 8, 3)
 
     Output:
         Converted quaternion to current position
     """
-    batch, vert_num, dim = start_pos.shape
-    out = torch.empty_like(start_pos)
-#     # print(quat.shape)
-#     # if not isinstance(quat, np.ndarray):
-#     #     quat = quat.astype('float64')
-#     # if not isinstance(start_pos, np.ndarray):
-#     #     start_pos = start_pos.astype('float64')
+    # print(start_pos.shape)
+    # print(quat.shape)
+    
+    if len(quat.shape) == 2:
 
+        batch, vert_num, dim = start_pos.shape
+        out = torch.empty_like(start_pos)
+    #     # print(quat.shape)
+    #     # if not isinstance(quat, np.ndarray):
+    #     #     quat = quat.astype('float64')
+    #     # if not isinstance(start_pos, np.ndarray):
+    #     #     start_pos = start_pos.astype('float64')
 
-    # for batch in range(out.shape[0]):
-    #     for vert in range(out.shape[1]):
-    #         out[batch, vert] = own_rotVecQuat(start_pos[batch, vert, :], quat[batch, :4]) + quat[batch, 4:]
 
-    rotated_start = fast_rotVecQuat(start_pos, quat[:,:4])
-    # 1024x3
+        # for batch in range(out.shape[0]):
+        #     for vert in range(out.shape[1]):
+        #         out[batch, vert] = own_rotVecQuat(start_pos[batch, vert, :], quat[batch, :4]) + quat[batch, 4:]
 
-    # rot_start = rotated_start.reshape((batch, vert_num, dim))
+        rotated_start = fast_rotVecQuat(start_pos, quat[:,:4])
+        repeated_trans = torch.repeat_interleave(quat[:, 4:], repeats=8, dim=0)
+        out = rotated_start + repeated_trans
+        return out.reshape((batch, vert_num, dim))
     
-    repeated_trans = torch.repeat_interleave(quat[:, 4:], repeats=8, dim=0)
-    out = rotated_start + repeated_trans
-    # print("here", out.shape)
+    else:
+        batch, vert_num, dim = start_pos.shape
+        out = torch.empty((quat.shape[1], batch, vert_num, dim))
+    #     # print(quat.shape)
+    #     # if not isinstance(quat, np.ndarray):
+    #     #     quat = quat.astype('float64')
+    #     # if not isinstance(start_pos, np.ndarray):
+    #     #     start_pos = start_pos.astype('float64')
+
+
+        # for batch in range(out.shape[0]):
+        #     for vert in range(out.shape[1]):
+        #         out[batch, vert] = own_rotVecQuat(start_pos[batch, vert, :], quat[batch, :4]) + quat[batch, 4:]
+        for frame in range(quat.shape[1]):
+            rotated_start = fast_rotVecQuat(start_pos, quat[:,frame,:4])
+            repeated_trans = torch.repeat_interleave(quat[:,frame,4:], repeats=8, dim=0)
+            out[frame] = (rotated_start + repeated_trans).reshape((batch, vert_num, dim))
+
+        # print(torch.swapaxes(out, 0, 1).shape)
+        # exit()
+        return out
 
+    # print("here", out.shape)
 
-    return out.reshape((batch, vert_num, dim))
-    return out.reshape((out.shape[0], -1))
 
+    
 def log_quat2pos(log_quat, start_pos):
     """
 
@@ -105,8 +130,9 @@ def log_quat2pos(log_quat, start_pos):
     # log_quat = log_quat.astype('float64')
     # start_pos = start_pos.astype('float64')
     rot_vec = log_quat[:, :3]
-    angle = log_quat[:,3]
-    trans = log_quat[:,4:]
+    angle = log_quat[:, 3]
+    trans = log_quat[:, 4:]
+
     cos = torch.cos(angle/2).reshape(-1, 1)
     sin = torch.sin(angle/2)
 
@@ -116,7 +142,7 @@ def log_quat2pos(log_quat, start_pos):
     part1_1 = rot_vec * torch.vstack([sin]*3).T
     quat[:, 1:4] = part1_1
 
-    return quat2pos(quat, start_pos)
+    return quat2pos(quat.append(trans), start_pos)
 
 
 def diff_pos_start2pos(true_preds, start_pos):
diff --git a/code/lstm.py b/code/lstm.py
index 072538e..631569e 100644
--- a/code/lstm.py
+++ b/code/lstm.py
@@ -69,7 +69,7 @@ class MyDataset(data.Dataset):
                 data = data_all[self.data_type]
                 for frame in range(len(data) - (self.n_frames_perentry + 1)):
 
-                    self.start_pos.append(data_all["pos"][0].reshape(-1, 24).squeeze())
+                    self.start_pos.append(data_all["pos"][0])
                     train_end = frame + self.n_frames_perentry
                     self.data.append(data[frame:train_end].reshape(-1, self.n_datap_perframe))
                     self.target.append(data[frame+1:train_end+1].reshape(-1, self.n_datap_perframe))
@@ -224,7 +224,7 @@ config = dict(
     loss_type = "L1",
     loss_reduction_type = "mean",
     optimizer = "Adam",
-    data_type = "pos",
+    data_type = "log_quat",
     architecture = "lstm",
     train_sims = list(train_sims),
     test_sims = list(test_sims),
diff --git a/code/torch_nn.py b/code/torch_nn.py
index dd3d61b..94badfa 100644
--- a/code/torch_nn.py
+++ b/code/torch_nn.py
@@ -232,7 +232,7 @@ config = dict(
     loss_type = "L1",
     loss_reduction_type = "mean",
     optimizer = "Adam",
-    data_type = "quat",
+    data_type = "log_quat",
     architecture = "fcnn",
     train_sims = list(train_sims),
     test_sims = list(test_sims),
diff --git a/code/wandb/latest-run b/code/wandb/latest-run
index e8ce767..bd85e9f 120000
--- a/code/wandb/latest-run
+++ b/code/wandb/latest-run
@@ -1 +1 @@
-run-20220815_151207-2i29pl3z
\ No newline at end of file
+run-20220817_171844-1tooxyqr
\ No newline at end of file
