diff --git a/code/convert.py b/code/convert.py
index 1c5957b..f47f4ba 100644
--- a/code/convert.py
+++ b/code/convert.py
@@ -1,3 +1,4 @@
+from tracemalloc import start
 import torch
 import numpy as np
 from new_mujoco import fast_rotVecQuat, own_rotVecQuat
@@ -23,7 +24,7 @@ def eucl2pos(eucl_motion, start_pos):
         out = torch.empty_like(start_pos)
         for batch in range(out.shape[0]):
             out[batch] =  (eucl_motion[batch, :9].reshape(3,3) @ start_pos[batch].T + torch.vstack([eucl_motion[batch, 9:]]*8).T).T
-            
+
     # In case of LSTM
     else:
         out = torch.empty((eucl_motion.shape[0], eucl_motion.shape[1], start_pos.shape[-2], start_pos.shape[-1]))
@@ -64,10 +65,10 @@ def quat2pos(quat, start_pos):
     if len(quat.shape) == 2:
 
         batch, vert_num, dim = start_pos.shape
+
         out = torch.empty_like(start_pos).to(device)
 
         rotated_start = fast_rotVecQuat(start_pos, quat[:,:4])
-        print(rotated_start)
         repeated_trans = torch.repeat_interleave(quat[:, 4:], repeats=8, dim=0)
         out = rotated_start + repeated_trans
 
@@ -77,7 +78,7 @@ def quat2pos(quat, start_pos):
     else:
         batch, vert_num, dim = start_pos.shape
         out = torch.empty((quat.shape[1], batch, vert_num, dim)).to(device)
-        
+
         for frame in range(quat.shape[1]):
             rotated_start = fast_rotVecQuat(start_pos, quat[:,frame,:4])
             repeated_trans = torch.repeat_interleave(quat[:,frame,4:], repeats=8, dim=0)
diff --git a/code/plot_data.py b/code/plot_data.py
index 3d76850..4377cb9 100644
--- a/code/plot_data.py
+++ b/code/plot_data.py
@@ -16,46 +16,53 @@ def load_model(data_type, architecture):
     model_dict = torch.load(f"models/{data_type}_{architecture}.pickle")
     config = model_dict['config']
     ndata_dict = model_dict['data_dict']
+
     model = Network(ndata_dict[config['data_type']], config)
     model.load_state_dict(model_dict['model'])
     model.eval()
     print("Current model: \n", model)
+
     return model
 
-def get_random_sim_data():
+def get_random_sim_data(data_type, nr_frames):
     # Select random simulation
     i = randint(0, 749)
 
     print("Using simulation number ", i)
     with open(f'data/sim_{i}.pickle', 'rb') as f:
         file = pickle.load(f)
+
         start_pos = torch.tensor(file["data"]["pos"][0], dtype=torch.float32)
-        start_pos = start_pos[None, :].repeat(225, 1, 1)
+        start_pos = start_pos[None, :].repeat(nr_frames, 1, 1)
 
         data_tensor = torch.tensor(file["data"][data_type], dtype=torch.float32)
+
+        # Get data as data_type
         original_data = data_tensor.flatten(start_dim=1)
 
-        plot_data = convert(data_tensor.flatten(start_dim=1), start_pos, data_type).reshape(225, 8, 3)
+        # Convert to pos data for plotting
+        plot_data = convert(data_tensor.flatten(start_dim=1), start_pos, data_type).reshape(nr_frames, 8, 3)
+
 
     return plot_data, original_data
 
-def get_prediction(data, data_type, original_data):
+def get_prediction(original_data, data_type, xyz_data):
     # Collect prediction of model given simulation
-    result = torch.zeros_like(original_data)
-    start_pos = original_data[0][None, :]
+    # Result should be xyz data for plot
+    result = torch.zeros_like(xyz_data)
+
+    # Get first position
+    start_pos = xyz_data[0][None, :]
 
-    for frame_id in range(20, data.shape[0]):
+    for frame_id in range(20, xyz_data.shape[0]):
         # Get 20 frames shape: (1, 480)
-        input_data = data[frame_id - 20 : frame_id]
+        input_data = original_data[frame_id - 20 : frame_id]
         input_data = input_data.flatten()[None, :]
 
         # Save the prediction in result
         with torch.no_grad(): # Deactivate gradients for the following code
             prediction = model(input_data)
-            print("start",start_pos)
-            print(prediction)
-            print(convert(prediction, start_pos, data_type))
-            exit()
+
             result[frame_id] = convert(prediction, start_pos, data_type)
 
 
@@ -82,7 +89,7 @@ def plot_3D_animation(data, result):
 
     cube_result = result[0]
     cube_result = cube_result[np.array([0, 1, 2, 3, 4, 5, 6, 7]), :][np.array([0,1,3,2,6,7,5,4]), :]
-    
+
     X, Y, Z = first_cube[:, 0], first_cube[:, 1], first_cube[:, 2]
     X_pred, Y_pred, Z_pred = cube_result[:, 0], cube_result[:, 1], cube_result[:, 2]
 
@@ -133,13 +140,14 @@ def plot_3D_animation(data, result):
 
 
 if __name__ == "__main__":
-    data_type = "quat"
+    nr_frames = 225
+    data_type = "log_quat"
     architecture = "fcnn"
 
     model = load_model(data_type, architecture)
 
-    plot_data, data = get_random_sim_data()
+    plot_data, ori_data = get_random_sim_data(data_type, nr_frames)
 
-    prediction = get_prediction(data, data_type, plot_data)
+    prediction = get_prediction(ori_data, data_type, plot_data)
 
     plot_3D_animation(plot_data, prediction)
diff --git a/code/torch_nn.py b/code/torch_nn.py
index a98b9a8..64f1fc0 100644
--- a/code/torch_nn.py
+++ b/code/torch_nn.py
@@ -249,7 +249,7 @@ if __name__ == "__main__":
         loss_type = "L1",
         loss_reduction_type = "mean",
         optimizer = "Adam",
-        data_type = "log_quat",
+        data_type = "eucl_motion",
         architecture = "fcnn",
         train_sims = list(train_sims),
         test_sims = list(test_sims),
diff --git a/code/wandb/latest-run b/code/wandb/latest-run
index d3d24c4..3c2c5e9 120000
--- a/code/wandb/latest-run
+++ b/code/wandb/latest-run
@@ -1 +1 @@
-run-20220927_171352-14vsdsc6
\ No newline at end of file
+run-20220928_113146-7nd5alt0
\ No newline at end of file
