diff --git a/code/convert.py b/code/convert.py
index e33f20f..1646302 100644
--- a/code/convert.py
+++ b/code/convert.py
@@ -57,8 +57,13 @@ def eucl2pos(eucl_motion, start_pos):
 
 
 def quat2pos(quat, start_pos):
-    """
+    # print(quat.shape, start_pos.shape)
+    # NN
+    # (128 x 7), (128 x 8 x 3)
+    # LSTM
+    # (128 x 20 x 7), (128 x 8 x 3)
 
+    """
     Input:
         quat: Original predictions (quaternion motion)
             (batch, .., 7)
@@ -68,59 +73,37 @@ def quat2pos(quat, start_pos):
     Output:
         Converted quaternion to current position
     """
-    # print(start_pos.shape)
-    # print(quat.shape)
-    
+
+
     if len(quat.shape) == 2:
 
         batch, vert_num, dim = start_pos.shape
         out = torch.empty_like(start_pos)
-    #     # print(quat.shape)
-    #     # if not isinstance(quat, np.ndarray):
-    #     #     quat = quat.astype('float64')
-    #     # if not isinstance(start_pos, np.ndarray):
-    #     #     start_pos = start_pos.astype('float64')
-
-
-        # for batch in range(out.shape[0]):
-        #     for vert in range(out.shape[1]):
-        #         out[batch, vert] = own_rotVecQuat(start_pos[batch, vert, :], quat[batch, :4]) + quat[batch, 4:]
 
         rotated_start = fast_rotVecQuat(start_pos, quat[:,:4])
         repeated_trans = torch.repeat_interleave(quat[:, 4:], repeats=8, dim=0)
         out = rotated_start + repeated_trans
         return out.reshape((batch, vert_num, dim))
-    
+
     else:
         batch, vert_num, dim = start_pos.shape
         out = torch.empty((quat.shape[1], batch, vert_num, dim))
-    #     # print(quat.shape)
-    #     # if not isinstance(quat, np.ndarray):
-    #     #     quat = quat.astype('float64')
-    #     # if not isinstance(start_pos, np.ndarray):
-    #     #     start_pos = start_pos.astype('float64')
-
-
-        # for batch in range(out.shape[0]):
-        #     for vert in range(out.shape[1]):
-        #         out[batch, vert] = own_rotVecQuat(start_pos[batch, vert, :], quat[batch, :4]) + quat[batch, 4:]
         for frame in range(quat.shape[1]):
             rotated_start = fast_rotVecQuat(start_pos, quat[:,frame,:4])
             repeated_trans = torch.repeat_interleave(quat[:,frame,4:], repeats=8, dim=0)
             out[frame] = (rotated_start + repeated_trans).reshape((batch, vert_num, dim))
 
-        # print(torch.swapaxes(out, 0, 1).shape)
-        # exit()
         return out
 
-    # print("here", out.shape)
-
 
 
 def log_quat2pos(log_quat, start_pos):
-    print(start_pos, log_quat)
+    # print(start_pos.shape, log_quat.shape)
+    # NN
+    # (128 x 7), (128 x 8 x 3)
+    # LSTM
+    # (128 x 20 x 7), (128 x 8 x 3)
     """
-
     Input:
         log_quat: Original predictions (log quaternion motion)
         start_pos: Start position of simulation
@@ -128,31 +111,52 @@ def log_quat2pos(log_quat, start_pos):
     Output:
         Converted log quaternion to current position
     """
-    # log_quat = log_quat.astype('float64')
-    # start_pos = start_pos.astype('float64')
-    rot_vec = log_quat[:, :3]
-    angle = log_quat[:, 3]
-    trans = log_quat[:, 4:]
+    if len(log_quat.shape) == 2:
+        rot_vec = log_quat[:, :3]
+        angle = log_quat[:, 3]
+        trans = log_quat[:, 4:]
+
+        cos = torch.cos(angle/2).reshape(-1, 1)
+        sin = torch.sin(angle/2)
+
+
+        quat = torch.empty(log_quat.shape)
+        quat[:, 0] = cos.squeeze()
+        part1_1 = rot_vec * torch.vstack([sin]*3).T
+        quat[:, 1:4] = part1_1
+        quat[:, 4:] = trans
+
+        # print(quat.shape)
+        # exit()
+
+        return quat2pos(quat, start_pos)
+    else:
+        rot_vec = log_quat[:, :, :3]
+        angle = log_quat[:, :, 3]
+        trans = log_quat[:, :, 4:]
 
-    cos = torch.cos(angle/2).reshape(-1, 1)
-    sin = torch.sin(angle/2)
+        cos = torch.cos(angle/2).reshape(-1, 1)
+        print(cos.shape)
+        sin = torch.sin(angle/2)
 
+        quat = torch.empty(log_quat.shape)
+        quat[:, :, 0] = cos
+        quat[:, :, 1:4] = rot_vec * torch.vstack([sin]*3).T
+        quat[:, :, 4:] = trans
 
-    quat = torch.empty(log_quat.shape)
-    quat[:, 0] = cos.squeeze()
-    part1_1 = rot_vec * torch.vstack([sin]*3).T
-    quat[:, 1:4] = part1_1
+        return quat2pos(quat, start_pos)
 
-    return quat2pos(quat.append(trans), start_pos)
 
+# start = [[[1,0,0],[2,0,0],[0.5,0,0]],
+#             [[0,1,0],[0,2,0],[0,0.5,0]]]
 
-start = [[[1,0,0],[2,0,0],[0.5,0,0]],
-            [[0,1,0],[0,2,0],[0,0.5,0]]]
+# start_nn = [[[1,0,0],[2,0,0],[0.5,0,0]]]
 
-log_quat = [[[1,0,0.7,0.4,0,0,-0.2]],
-            [[0.3,0,0.7,0.4,0,0,-0.3]]]
+# log_quat = [[[1,0,0.7,0.4,0,0,-0.2]],
+#             [[0.3,0,0.7,0.4,0,0,-0.3]]]
+# log_quat_nn = [[[1,0,0.7,0.4,0,0,-0.2]]]
 
-log_quat2pos(log_quat, start)
+# log_quat2pos(log_quat, start)
 
 
 def diff_pos_start2pos(true_preds, start_pos):
diff --git a/code/lstm.py b/code/lstm.py
index 631569e..46e91d6 100644
--- a/code/lstm.py
+++ b/code/lstm.py
@@ -102,7 +102,7 @@ def train_model(model, optimizer, data_loader, test_loader, loss_module, num_epo
     # Training loop
     for epoch in range(num_epochs):
         loss_epoch = 0
-        for data_inputs, data_labels, _ in data_loader:
+        for data_inputs, data_labels, start_pos in data_loader:
             data_inputs = data_inputs.to(device)
             data_labels = data_labels.to(device)
             # print(data_inputs.shape)
@@ -116,11 +116,11 @@ def train_model(model, optimizer, data_loader, test_loader, loss_module, num_epo
 
             output, _ = model(data_inputs)
 
-            # alt_preds = convert(preds, start_pos, data_loader.dataset.data_type)
-            # alt_labels = convert(data_labels, start_pos, data_loader.dataset.data_type)
-            # loss = loss_module(alt_preds, alt_labels)
+            alt_preds = convert(output, start_pos, data_loader.dataset.data_type)
+            alt_labels = convert(data_labels, start_pos, data_loader.dataset.data_type)
+            loss = loss_module(alt_preds, alt_labels)
 
-            loss = loss_module(output.squeeze(), data_labels.float())
+            # loss = loss_module(output.squeeze(), data_labels.float())
 
             optimizer.zero_grad()
             # Perform backpropagation
diff --git a/code/new_mujoco.py b/code/new_mujoco.py
index 5e96333..901482e 100644
--- a/code/new_mujoco.py
+++ b/code/new_mujoco.py
@@ -77,22 +77,22 @@ def rotVecQuat(v, q):
     mujoco_py.functions.mju_rotVecQuat(res, v, q)
     return res
 
-# testing rotVecQuat vs own_rotVecQuat
-v_big = torch.tensor([[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]],
-                        [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]])
+# # testing rotVecQuat vs own_rotVecQuat
+# v_big = torch.tensor([[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]],
+#                         [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]])
 
-q_big = torch.tensor([[0.3,  0.87, 0.0, 0.707], 
-                        [0.3,  0.87, 0.0, 0.707]])
+# q_big = torch.tensor([[0.3,  0.87, 0.0, 0.707], 
+#                         [0.3,  0.87, 0.0, 0.707]])
 
-# q_big = torch.repeat_interleave(q_big, repeats=8, dim=0)
+# # q_big = torch.repeat_interleave(q_big, repeats=8, dim=0)
 
 
-v = torch.tensor([1, 0, 0])
-q = torch.tensor([0.3,  0.87, 0.0, 0.707])
+# v = torch.tensor([1, 0, 0])
+# q = torch.tensor([0.3,  0.87, 0.0, 0.707])
 
-print("fast",fast_rotVecQuat(v_big, q_big))
-print("own",own_rotVecQuat(v, q))
-# print("ori", rotVecQuat(v.astype(np.float64), q.astype(np.float64)))
+# print("fast",fast_rotVecQuat(v_big, q_big))
+# print("own",own_rotVecQuat(v, q))
+# # print("ori", rotVecQuat(v.astype(np.float64), q.astype(np.float64)))
 
 def get_vert_coords_quat(sim, obj_id, xyz_local):
     """
diff --git a/code/results/log_quat/400_0.1_L1.txt b/code/results/log_quat/400_0.1_L1.txt
index 37ac020..e4e1d45 100644
--- a/code/results/log_quat/400_0.1_L1.txt
+++ b/code/results/log_quat/400_0.1_L1.txt
@@ -78,3 +78,19 @@
 
 [390, nan, 39.4988618739, nan] 
 
+[0, 178.8403033088, 31.418726304, 99.4773236443] 
+
+[10, 51.1406788545, 31.2205307904, 54.9712273093] 
+
+[20, 25.2061444451, 37.3080875172, 39.2535400391] 
+
+[30, 18.9248639275, 44.4319314396, 32.1002699908] 
+
+[40, 17.8655628878, 44.3445865407, 29.3218240177] 
+
+[50, 17.0572779038, 42.0464046703, 36.0767104205] 
+
+[60, 15.3679630055, 49.1547528435, 31.6100284352] 
+
+[70, 16.5515405991, 49.6468972599, 32.806001551] 
+
diff --git a/code/results/quat/400_0.1_L1.txt b/code/results/quat/400_0.1_L1.txt
index acd198a..bb94ad1 100644
--- a/code/results/quat/400_0.1_L1.txt
+++ b/code/results/quat/400_0.1_L1.txt
@@ -146,3 +146,5 @@
 
 [390, 16.6783752441, 32.4482134651, 31.4818617877] 
 
+[0, 172.6938620175, 38.0000035903, 83.811221852] 
+
diff --git a/code/wandb/latest-run b/code/wandb/latest-run
index 02383cc..1e680fd 120000
--- a/code/wandb/latest-run
+++ b/code/wandb/latest-run
@@ -1 +1 @@
-run-20220819_150001-2659xw1x
\ No newline at end of file
+run-20220819_161958-18y6b2p7
\ No newline at end of file
